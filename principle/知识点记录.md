## JavaScript

#### 1、前端性能优化
  - manifest静态资源缓存，如果已有缓存资源，会与服务器最后修改时间对比，一致则返回304，直接使用已缓存资源
    - 优势：
      > - 离线浏览 - 用户可在应用离线时使用它们
      > - 速度 - 已缓存资源加载得更快
      > - 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源  

    - 实现原理
      ```html
        <html manifest="manifest.appcache"></html>
      ```
      ```js
        // 设置后面的文件为缓存
        CACHE:
        /static/js/app.js

        // 置后面的文件为不缓存（无法设置自身页面）
        NETWORK:

        // 置后面的文件错误或不存在的时候使用另一个文件(404页面)
        FALLBACK:
        /static/errpage.html

        // 可以设置fast或prefer-online两种模式
        SETTINGS:
      ```
  - 缓存部分数据，尽可能减少http请求，合理使用http缓存
    - 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求
      > 设置请求头Cache-Control/Max-Age

    - 协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存
      > If-None-Match/E-tag

  - Service Worker
    - 介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。实现离线缓存。
    - 缓存资源，能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作，提高二次访问首屏速度，也为创建PWA（桌面WEB）的实现提供服务。
    - 特点：
      - 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听 - 和截拦作用域范围内所有页面的 HTTP 请求。
      - 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)
      - 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求
      - 单独的作用域范围，单独的运行环境和执行线程
      - 不能操作页面 DOM。但可以通过事件机制来处理
      - 事件驱动型服务线程

  - 尽可能少使用setInterval(会产生阻塞队列，使用setTimeout递归来模拟实现setInterval功能)、watch（变量不会被垃圾回收机制回收）等观察者模式的方法，避免滥用async、await异步函数（会产生阻塞队列）

  - 使用Web Workers分担部分计算密集型或高延迟的任务，主线程不会被阻塞或拖慢。
    ```javascript
      // 主线程
      let worker = new Worker('worker.js')
      worker.postMessage({ method: 'echo', args: ['Work'] }) // 主线程向worker线程发送数据

      worker.onmessage = function (event) {
        // 主线程监听worker线程返回数据
        console.log('Received message ' + event.data)
        worker.postMessage('Work done!')
      }

      // 错误处理
      worker.onerror(function (event) {
        console.log(event)
      })

      worker.terminate()  // 关闭worker线程
      ```
      ```javascript
      // worker 线程
      // 子线程监听主线程传输的数据
      self.addEventListener('message', function (e) {
        self.postMessage('You said: ' + e.data) // 向主线程发送数据
      }, false)

      self.close() // 关闭自身线程

      self.importScripts('script1.js') // 子线程加载其他js脚本
    ```
  - 组件、模块通过懒加载或按需加载减少首屏加载时长（服务端渲染ssr也可以减少首屏渲染白屏时长）

  - 异步子组件优化页面加载时长
  ```javascript
    Vue.component(
      'async-webpack-example',
      // 这个 `import` 函数会返回一个 `Promise` 对象。
      () => import('./my-async-component')
    )
  ```
  - Object.freeze() 对象冻结减少CPU（observer）开销 [(源)](https://juejin.im/post/5b960fcae51d450e9d645c5f)
    > Object.freeze() 可以冻结一个对象，冻结之后不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回被冻结的对象。

    > 当你把一个普通的 JavaScript 对象传给 Vue 实例的  data  选项，Vue 将遍历此对象所有的属性，并使用  Object.defineProperty  把这些属性全部转为 getter/setter，这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

    > Vue 在遇到像 Object.freeze() 这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法。

  - 减少重绘和回流，减少dom操作，使用className代替直接使用style编写样式、减少class选择器的层级嵌套、减少元素标签的使用

  - 图片、图标应先压缩合并，部署其他前静态资源前也应先压缩，使用CDN优化加载效率、
上传图片等资源压缩后再上传
    - CDN 静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。

  - 图片懒加载 / 图片预加载
    - 懒加载原理：先加载一张白块或低品质图片，当页面停止在可视范围后加载真实图片，滚动事件通过函数节流来控制
      ```html
        <img src="/static/img/white.jpeg" original="/static/img/realImage.png">
        <!--
          src 中为白块或低品质图片
          original 中为真实图片
          在可视范围时使用original中的真实图片地址替换src中的地址
         -->
      ```

#### 2、vue等单页项目 首屏加载白屏是怎么处理的
  - 交互设计
    - 给个loading动画，过度资源加载过程
    - 设计占位图和loading，页面加载完成后替换
    - 一屏可视组件优先加载

  - 代码优化
    - 考虑对于页面的组件异步加载
    - webpack打包优化，减小打包文件体积大小
    - vuejs路由的懒加载，减少首屏加载资源
    - 配置vue-cli，利用webpack插件完成模板预加载
    - 考虑服务器渲染首屏骨架页面，或者使用服务器渲染策略ssr
    - 首页数据初始化和js包同时加载
    - js拆包

#### 3、node给前端带来了哪些变化（应用场景）
  - 使用node开发后端
  - react、vue等前端框架辅助开发(webpack)
  - 桌面应用、插件等（atom）

#### 4、typescript 和 JavaScript 的区别
  - typescript 是静态的强类型语言
    - 增加了静态类型、类（面向对象）、模块、接口和类型注解（变量类别必须在头部使用注解定义才可使用）
    - 静态类型化是一种功能，可以在开发人员编写脚本过程中即可检测错误
    - 可用于开发大型的应用(deno等)

  - JavaScript 是动态的弱类型语言
    - 不支持面向对象语言所具有的继承和重载功能
    - 变量可以在任意地方定义和修改，并且会产生变量提升的问题、优势也是弱势、合作开发容易产出不可预料的错误
    - 没有类的概念，es6中的class仍是使用prototype来实现继承

#### 5、闭包
  - 指一个函数内部返回另一个函数，而这个内部函数使用了父级的变量，在这个函数被调用时即产生了闭包。
  - 形成闭包的函数的内部变量不会被垃圾回收机制所销毁

#### 6、JavaScript实现继承的几种方式
```JavaScript
  // 构造函数
  function People (name) {
    // 构造属性
    this.name = name
    this.sleep = function () {
      console.log(name + ':sleep')
    }
  }
  // 原型
  People.prototype.eat = function (food) {
    console.log(food)
  }

  1、原型链继承
  function People1 () {}
  People1.prototype = new People()
  // 方法重载
  People1.prototype.eat = function (food) {
    console.log(food)
  }

  2、构造继承（使用父级的构造函数来增加子类属性）
  function People2 () {
    People.call(this)
    this.like = 'cooding'
  }

  3、实例继承
  function People3 (name) {
    let people = new People()
    people.name = name || 'Tom'
    return people
  }

  4、拷贝继承
  function People4 (name) {
    let people = new People()
    for (let key in people) {
      People4.prototype[key] = people[key]
    }
  }

  5、组合继承 ****
  function People5 (name) {
    People.call(this)
  }
  People5.prototype = new People()
  // 需要修复构造函数指向
  People5.prototype.constructor = People5

  6、class继承
  class People6 extends People {
    constructor(name) {
      super(name)
    }
  }
```

#### 7、webpack理解
  - webpack 是模块化项目构建工具，通过Loader转换文件，通过Plugin注入钩子，最后输出由多个模块组合成的文件。符合生产环境部署的前端资源。

  - 与其他构建工具（gulp等）的区别：
    - gulp
      - gulp 是流程化项目构建工具，通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。
      - gulp工作方式：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。
    - webpack
      - 更注重强调模块化开发，把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。


  - loader 的机制
    - 用来加载处理各种形式的资源，本质上是一个函数，接受文件作为参数，返回转化后的结构。
    - 用于对模块的源代码进行转换。其类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法

    ```js
      rules: [
        {
          test: /\.vue/,
          use: [
            {
              loader: 'vue-loader',
              include: [resolve('src')],
              options: {
                ...
              }
            }
          ]
        }
      ]
    ```
  - plugin
    - 一个JavaScript函数或者class（ES6语法）。
    - 在它的原型上定义一个apply方法。
    - 指定挂载的webpack事件钩子。
    - 处理webpack内部实例的特定数据。
    - 功能完成后调用webpack提供的回调。

  ```js
    // Compiler对象代表了完整的 webpack 环境配置。
    // 这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。
    import { Compiler } from 'webpack'

    // 创建一个新的 compiler 实例
    const compiler = new Compiler()

    compiler.options = {...} // 填充所有必备的 options 选项

    class PluginDemo {
      apply (compiler) {
        compiler.plugin('emit', function(compilation, callback) {
          // 执行一些异步……
          setTimeout(function() {
            console.log('异步运行完成...');
            callback()
          }, 1000)
        })
      }
    }
  ```

  - webpack 常见的事件钩子


  |钩子|作用|参数|类型|
  |---|---|---|---|
  | after-plugins  | 设置完一组初始化插件之后 | compiler | sync |
  | after-resolvers| 设置完resolvers之后    | compiler | sync |
  | run	           | 在读取记录之前	       | compiler |	async |
  | compile        | 在创建新compilation之前|	compilationParams |	sync             |
  | compilation    | compilation创建完成   |	compilation |	sync|
  | emit           | 在生成资源并输出到目录之前|	compilation |	async|
  | after-emit     | 在生成资源并输出到目录之后|	compilation |	async|
  | done           | 完成编译|	stats |	sync |

  - loader 和 plugin 的区别
    - loader是用来对模块的源代码进行转换，而插件（plugin）目的在于解决 loader 无法实现的其他事。
    - plugin可以在任何阶段调用，能够跨Loader进一步加工Loader的输出，在构建运行期间，触发事件，执行预先注册的回调，使用compilation对象做一些更底层的事情。


#### 8、不同域名之间怎么实现数据通信（纯前端）
  - window.open页面通信
    ```javascript
      const childPage = window.open('child.html', 'child')

      childPage.onload = () => {
        childPage.postMessage('hello', location.origin)
      }

      // child.html
      window.onmessage = evt => {
        // evt.data
      }
      //缺点是只能与自己打开的页面完成通讯，应用面相对较窄；但优点是在跨域场景中依然可以使用该方案。
    ```

  - iframe 子页面向父页面发送信息
    ```javascript
      // parent.html
      window.addEventListener('message', function (e) {
        // 通过origin属性判断消息来源地址
        console.log(e.data)  
      }, false)

      // child.html
      var ifr = window.parent  //获取父窗体
      ifr.postMessage('这是传递给a.html的信息', location.origin);
    ```
  - localStorage （跨浏览器无效）
  - cookie （要求domain域名一致，或子域名相同）
  - webSocket (需要后端来维护)
    > 它实现了浏览器与服务器全双工通信，同时允许跨域通讯

    ```javascript
      //新建一个WebSocket对象，
      var ws = new WebSocket('ws://127.0.0.1:8080/url');
      //注意服务器端的协议必须为“ws://”或“wss://”，其中ws开头是普通的websocket连接，wss是安全的websocket连接，类似于https。
      // 连接被打开时调用
      ws.onopen = function () {};

      // 在出现错误时调用，例如在连接断掉时
      ws.onerror = function (e) {};

      // 在连接被关闭时调用
      ws.onclose = function () {};

      ws.onmessage = function(msg) {
        // 在服务器端向客户端发送消息时调用
        // msg.data包含了消息
      };
      // 这里是如何给服务器端发送一些数据
      ws.send('some data');
      // 关闭套接口
      ws.close();
    ```

  - JSONP跨域通信
    > 原理：主要是利用script标签不受同源策略限制的特性

    ```javascript
    <script type="text/javascript">
      // 创建script标签
      var url = 'http://localhost.com/api?id=1&callback=jsonpCb'
      var _script = document.createElement('script')
      _script.setAttribute('src', url)
      document.getElementsByTagName('head')[0].appendChild(_script)

      // script标签挂载后回调
      function jsonpCb (data) {
        console.log('name:' + data.name)
      }
    </script>
    ```

#### 9、canvas 和 svg 的区别
  - canvas 是画布，通过JavaScript来绘制，可绘制2D、3D图形，依赖分辨率 适合做动画
  - svg 是矢量图形，是xml的一种元素标签，可以通过操作dom元素的方法来控制，不会根据大小尺寸的变化而影响分辨率

#### 10、函数去抖 和 函数节流（[源](https://www.jianshu.com/p/0dbe40b7c1cf)）
  - 函数去抖：当事件触发之后，必须等待某一个时间之后，回调函数才会执行，假若再等待的时间内，事件又触发了则等待时间刷新。
    ```javascript
      var debounce = function(delay, cb) {
        var timer;
        return function() {
          if (timer) clearTimeout(timer);
          timer = setTimeout(function() {
            cb();
          }, delay);
        }
      }
    ```

  - 函数节流：当事件触发之后，按照一个固定时间周期执行。
    ```javascript
      var throttle = function(delay, cb) {
      var startTime = Date.now();
        return function() {
          var currTime = Date.now();
          if (currTime - startTime > delay) {
              cb();
              startTime = currTime;
          } else {
            timer = setTimeout(cb , delay);
          }
        }
      }
    ```
  - demo: window.resize或window.scroll
    - 使用函数去抖后，会在停止resize事件后等待某时间触发回调
    - 使用函数节流，会导致resize事件固定时间周期触发一次事件回调


#### 11、this关键字
  - this是JavaScript的一个关键字，通常情况下指代调用它的那个对象，随着使用的场合不同，它的值会发生改变。
    - 在浏览器中默认情况下指代window对象
    - 在自执行函数中默认指代window对象
    - 在一般函数中默认指代函数本身
    - 通过new关键字生成的实例对象，this会指向实例本身
  - 通过使用call、apply、bind可以手动改变this的指代对象

  - call、apply、bind的主要区别 传参的方式不一样
    ```js
      let obj = { name: 'xm' }
      function test (argu, argu2) {
        let name = 'tt'
        console.log(this.name + ':' + argu + '、' + argu2)
      }
      test.call(obj, 'sleep', 'coding')
      test.apply(obj, ['sleep', 'coding'])

      // bind 返回的是一个函数
      // 用法1：
      let test1 = test.bind(obj)
      test1('sleep', 'coding')
      // 用法2：
      let test2 = test.bind(obj, 'sleep', 'coding')
      test2()
    ```

#### 12、原型、原型链
  - 原型对象：即指的是prototype对象
    - 通过对象直接量创建的对象Object.prototype作为他的原型
    - 通过new创建的对象使用构造函数的prototype对象作为原型
    - 通过Object.create()创建的对象使用第一个参数作为原型，也可以是null
  - 原型链：每个对象都有一个指向它的原型对象（prototype）的内部链接(__proto__ 原型指针)。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（ Object.prototype.__proto__ ），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。

  ```js
    function Person () {}
    let person1 = new Person()

    Object.prototype.__proto__ // null
    Function.prototype.__proto__ === Object.prototype
    Function.__proto__ === Function.prototype // 特例 唯一一个原型指针指向本身原型对象
    Object.__proto__ === Function.prototype // Object、Date等 属于构造函数
    Person.__proto__ === Function.prototype
    person1.__proto__ === Person.prototype
  ```


#### 13、浏览器攻击（XSS、CSRF）[来源](https://mp.weixin.qq.com/s/sjy-Kul5y0Wj-HJwQn7gBA)
    - XSS 跨站脚本注入攻击
      - 原理：服务端过于信任客户端提交的数据，没有对提交的信息进行过滤
      - 解决：
        1. 输入输出内容检查并过滤
        2. Cookie中设置HttpOnly (设置HttpOnly的Cookie通过js脚本将无法读取到)

    - CSRF 跨站请求伪造(挟持)
      - 要求：
        1. 登录受信任网站A，并在本地生成Cookie。
        2. 在不登出A的情况下，访问危险网站B。B网站拿到A网站的cookie，并发送请求。
      - 解决：
        1. 验证码
        2. 请求验证Referer来源
        3. token验证（jwt）

#### 14、[http协议原理](./http协议/http协议.md)
  - http (Hyper Text Transfer Protocol) 超文本传输协议
    - http请求过程
      - DNS解析 -> 建立TCP连接 -> 发送请求头和请求行 -> 发送请求体 -> 等待服务器返回首字节(响应头) -> 接收数据
    - HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
  - http常用状态码

    - 100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息

    - 200  OK         正常返回信息
    - 201  Created    请求成功并且服务器创建了新的资源
    - 202  Accepted   服务器已接受请求，但尚未处理
    - 206  Partial Content 成功执行了一个部分或Range(范围)请求。206响应中必须包含Content-Range、Date以及ETag或Content-Location首部。

      (重定向)
    - 301  Moved Permanently  请求的网页已永久移动到新位置。
    - 302  Found        临时性重定向。
    - 303  See Other    临时性重定向，且总是使用 GET 请求新的 URI。
    - 304  Not Modified 自从上次请求后，请求的网页未修改过。

      (客户端错误)
    - 400  Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
    - 401  Unauthorized 请求未授权。
    - 403  Forbidden    禁止访问。
    - 404  Not Found    找不到如何与 URI 相匹配的资源。

      (服务端错误)
    - 500  Internal Server Error  最常见的服务器端错误。
    - 503  Service Unavailable    服务器端暂时无法处理请求（可能是过载或维护）。

    ......

#### 15、JavaScript引擎的执行机制
  - 机制：JavaScript是一门单线程语言，执行机制是使用Event Loop ( 事件轮询 )
  - js的事件任务可以分为 宏任务(mocro-task) 和 微任务(micro-task)
    - 宏任务：script、setTimeout、setInterval
    - 微任务：promise的then方法、process.nextTick
  - 任务执行顺序
    - 首先执行script下的宏任务，遇到setTimeout等宏任务将其放置于宏任务队列中
    - 遇到promise先执行promise方法，然后将then方法放置入微任务队列中
    - 当本轮宏任务执行结束后执行本轮微任务（即then方法）
    - 当微任务执行结束后，本轮event loop执行完毕
    - 下一轮宏任务开始执行（即setTimeout）
    - ...

#### 16、浏览器渲染机制
  1. 处理 HTML 并构建 DOM 树。
  2. 处理 CSS 构建 CSSOM 树。
  3. 将 DOM 与 CSSOM 合并成一个渲染树。
  4. 根据渲染树来布局，计算每个节点的位置。
  5. 调用 GPU 绘制，合成图层，显示在屏幕上。

  ![渲染机制](../assets/image/浏览器渲染机制.png)


  - 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。

#### 17、浏览器事件流
  - 事件冒泡
    div -> body -> html -> dom
  - 事件捕获
    dom -> html -> body -> div

  - dom的事件流
    - 事件捕获 -> 事件冒泡
    - dom -> html -> body -> div -> body -> html -> dom

#### 18、WebView和原生是如何通信
  - 核心原理：需要一门语言实现Native端和H5端之间的双向通信，即JSBridge

  - JavaScript 通知 Native
    - API注入： Native获取JS环境的上下文，并直接挂在对象或方法，使js可以直接调用原生方法
    - webview中的prompt拦截，通过对webview信息冒泡传递拦截
    - webview url scheme调整拦截
  - Native 通知 Javascript
    Native拥有最高权限，可以直接通过 webview api 执行js代码

  - JSBridge的引入
    - 由js环境和Native客户端分别引入JSBridge包
    - 将两个部分的JSBridge包封装成Native SDK，由客户端统一引入，客户端在初始化webview打开页面时，如果页面在白名单中，即在HTML头部注入jsbridge

#### 19、ES6常用功能
  - let/const
  - 箭头函数 =>
  - 解构函数 let {a} = {a: 1}
  - 多行字符串/模板变量  `${a}`
  - 块级作用域
  - 函数默认参数 function (a = 1, b = false) {}
  - 扩展运算符 arr = [...arr, 1]
  - promise
    - 源于 jquery.deferred (<JQ_1.5)、jquery.deferred().promise() (>JQ_1.5)
    - Promise异常捕获 （Error、reject）
    - Promise.all、Promise.race
    ```js
      // 必须所有promise实例都加载完成
      promise.all([result1, result3]).then(datas => {
        console.log(datas) // datas 返回一包含两个Promise返回值的数组
      })

      // 只要一个promise实例加载完成 即执行 .then
      promise.race([result1, result3]).then(data => {
        console.log(data) // data 加载成功的实例的返回值
      })
    ```
    - 规范
      - Promise必须包含三种状态 pedding、fulfilled、rejected
      - 状态改变 pedding —> fulfilled 、pedding —> rejected
      - 状态不可逆
      - Promise必须实现.then()方法
      - .then方法可接收两个函数作为参数
      - .then方法必须返回一个Promise对象（默认返回自己本身）
      - Promise必须实现.catch()方法，可接收一个函数作为参数

  - proxy 代理
  - async、await
  - class类
  - 模块化 export、import
  - Set、Map

#### 22、设计原则
  - 开放封闭原则（对扩展开放，对修改封闭）

#### 21、Virtual Dom
  - 真实DOM操作效率低
  - Virtual Dom优点：使用js来模拟DOM结构，通过js比对DOM前后将发生的变化，并针对具体节点做修改，减少DOM重绘提高性能。
    ```js
      // vnode结构
      {
        tag: 'ul',
        attrs: { id: 'ulList' },
        children: [
          {
            tag: 'li',
            attrs: { className: 'item' },
            children: ['Li1—text']
          },
          {
            tag: 'li',
            attrs: { className: 'item' },
            children: ['Li2—text']
          }
        ]
      }
    ```
  - Virtual Dom常用API （snabbdom等虚拟dom库）
    - snabbdom 使用demo
      ```js
        <script type="text/javascript">
          var snabbdom = window.snabbdom
          var h = snabbdom.h

          var patch = snabbdom.init([
            snabbdom_class,
            snabbdom_props,
            snabbdom_style,
            snabbdom_eventlisteners
          ])

          // 表格属性
          var data = [
            { name: '姓名', age: '年龄', sex: '性别' },
            { name: 'undefind', age: '23', sex: '男' },
            { name: 'null', age: '18', sex: '女' }
          ]

          var app = document.getElementById('app')
          var vnode

          function render (data) {
            var newVnode = h('table', {}, [
              data.map(function(item) {
                var tds = []
                for (var key in item) {
                  if (item.hasOwnProperty(key)) {
                    tds.push(h('td', {}, item[key]))
                  }
                }
                return h('tr', {}, tds)
              })
            ])
            if (!vnode) {
              // 首次渲染
              patch(app, newVnode)
            } else {
              // re-render
              patch(vnode, newVnode)
            }
            vnode = newVnode
          }

          render(data)

          setTimeout(function () {
            data[1].age = 25
            data[2].name = 'test'
            data.push({ name: 'final', age: '20', sex: '女' })
            render(data)
          }, 5000)
        </script>
      ```
    - h函数：h('<标签名>', {...属性...}, [...子元素...])
    - patch函数： patch(app, vnode) 初次渲染节点、patch(vnode, newVnode)
      - patch(app, vnode)示例
        ```js
          function createElement (vnode) {
            var tag = vnode.tag
            var attrs = vnode.attrs || {}
            var children = vnode.children || []
            if (!tag) return null

            // 创建真实DOM元素
            var elem = document.createElement(tag)
            // 设置属性
            for (var attrName in attrs) {
              if (attrs.hasOwnProperty(attrName)) {
                elem.setAttribute(attrName, attrs[attrName])
              }
            }

            // 子元素
            children.forEach(function (childVnode) {
              // 递归添加子元素
              elem.appendChild(createElement(childVnode))
            })
            return elem
          }
        ```
      - patch(vnode, newVnode)简单示例
        ```js
          function updateChildren (vnode, newVnode) {
            var children = vnode.children || []
            var newChildren = newVnode.children || []

            children.forEach(function (childVnode, index) {
              if (childVnode.tag === newChildren[index].tag) {
                // 递归比对
                updateChildren(childVnode.children)
              } else {
                // 替换
                replaceChildren(vnode, newVnode)
              }
            })
          }

          function replaceChildren (vnode, newVnode) {
            let elem = vnode.elem // 真实DOM节点
            let newElem = document.createElement(newVnode)

            // 替换
          }
          // 节点新增和删除
          // 节点重新排序
          // 节点属性、样式、事件绑定
          // 极致压榨性能
          // ...
        ```

  - diff算法：比对差异
    - linux diff：比对两文件之间的差异
    - git diff：比对当前文件修改前修改后的差异

  - Virtual Dom中的diff算法的作用：找出前后两个vdom节点的差异，并仅更新差异部分

#### 22、jquery、zepto 和 vue、react的区别
  - vue数据和视图分离，解耦（开放封闭原则）
  - vue以数据驱动视图，只关心数据变化，DOM操作被封装
  - jquery等是操作真实DOM的库

  示例：[todo-list](./jquery和vue的区别)

#### 23、MVC 和 MVVM
  - M（Model） 数据源
  - V（View） 视图
  - C (Controller) 控制器
  - VM（ViewModel） 连接桥（连接M和V，view通过event-bind影响model，model通过data-bind影响view）

  - MVVM的三要素：
    - 响应式：vue监听data变化（数据劫持defineProperty 结合 发布者-订阅者模式）
    - 模板引擎：vue的如何解析模板，指令如何处理
      - 模板本质： 字符串
      - 将 模板 -> render函数（vm._c() 、vm._v()、vm._s()等）_ render函数返回vnode
      - v-model、v-for （vm._l() 函数）_、v-if等指令
    - 视图渲染：vue模板如何渲染成html，及渲染过程（通过patch函数初始化渲染及rerender）

#### 24、数据双向绑定实现原理 [参考](https://segmentfault.com/a/1190000006599500)
  - vue v-model 使用<font color="#d27377">数据劫持(defindeProperty)</font>结合<font color="#d27377">发布者-订阅者模式</font>实现  
  - [实现代码](./vue双向数据绑定.js)
  - 原理图
  ![原理图](../assets/image/数据双向绑定原理图.png)

#### 25、vue的实现流程
  - 模板解析成render函数
    - with的用法
    - 用render函数模拟模板中所有的DOM标签和属性
    - 并模板中用到的 data 中的属性，都变成了 JS 变量
    - 模板中的 v-model、v-for、v-on 都变成了 JS 逻辑
    - 最终 render 函数返回 vnode

  - 数据双向绑定（数据劫持defineProperty 结合 发布者-订阅者模式）
    - 劫持监听所有属性

  - DOM初始化渲染，订阅数据变化、绑定更新函数  
    - 初次渲染，执行 updateComponent，执行 vm._render()_
    - render函数会访问到变量，触发get方法
    - get方法会将变量添加到订阅器中
    - 执行 updateComponent ，会走到 vdom 的 patch 方法 （patch('app', vm._render()_)）
    - patch 将 vnode 渲染成 DOM，初次渲染完成

  - data属性变化，触发rerender更新函数
    - 修改属性，被响应式的 set 监听到
    - set 中触发 updateComponent
    - updateComponent 重新执行 vm._render()_
    - 生成的 vnode 和 prevVnode ，通过 patch 进行对比 patch(prevVnode, vnode)
    - 重新渲染指定DOM节点到html中

#### 26、组件化的理解
  - 组件化/模块化更易于团队的开发
  - 封装后的组件更易于维护，使用则不用关心组件内部逻辑
  - 组件可复用，基础组件可组合使用

#### 27、CSS BFC/IFC（内联元素格式化上下文）
  - BFC
    - 概念：块级格式化上下文
    - 原理（渲染规则）：
      - BFC垂直方向边距会发生重叠
      - BFC是一个独立的容器，内外元素不会互相影响
      - BFC容器计算高度时，内部浮动元素会参与计算（清除浮动的原理）
    - 创建BFC
      - float 值不为 none
      - position 值不为 static、relative
      - display 值为 table、table-cell、inline-block
      - overflow 值不为 visible

#### 28、DOM事件基本概念
  - DOM事件级别：
    - DOM0：elem.onClick(function () {})
    - DOM2：
      - IE：elem.attachEvent('click', function () {})
      - chrome等：elem.addEventListener('click', function () {}, false)
    - DOM3：elem.addEventListener('click', function () {}, false)

  - DOM事件模型 指事件捕获、事件冒泡
  - 事件流 捕获阶段 -> 目标阶段 -> 冒泡阶段
  - DOM捕获具体流程 window -> document -> html
  - Event对象：
    ```js
      event.preventDefault // 阻止默认事件
      event.stopPropagation // 阻止冒泡

      // 场景：一个按钮a、b两个事件，在a事件中添加该事件即可阻止b事件
      event.stoplmmediatePropagation // 事件优先级

      event.currentTarget // 始终返回绑定该事件的元素
      event.target // 返回触发事件的元素
    ```
  - 自定义事件
    ```js
      var event = new CustomEvent('customEv', options)
      elem.addEventListener('customEv', function (res) {
        /* res = options */
      })
      elem.dispatchEvent(event)
    ```

#### 29、事件冒泡和事件捕获 以及 事件委托
  - 事件冒泡：事件开始最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到根节点。
  - 事件捕获：接收事件的顺序为根节点到具体的节点。

  - DOM2级事件处理程序
    - addEventListener()和removeEventListener()。
    它们接受三个参数：处理的事件名称，事件处理程序，Boolean。true则为在事件捕获阶段处理，false为在事件冒泡阶段处理。

    ```javascript
      function handler () {
        alert('click')
      }
      dom.addEventListener('click', handler, false | true)
    ```

  - 事件委托
    - 利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如 ul li点击事件
    ```html
      <ul id="ul">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
      </ul>
    ```
    ```javascript
      let ul = document.getElementById('ul')
      ul.onclick = function (e) {
        e = e | window.event
        if (e.target.tagName.toLowerCase() === 'li') {
          console.log(e.target.innerHtml)
        }
      }
    ```
    - 优点
      - 可以大量节省内存占用，减少事件注册。
      - 可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适
    - 缺点：事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。

> 个人总结 欢迎纠正
