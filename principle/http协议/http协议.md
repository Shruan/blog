# HTTP协议
### http协议原理
  - http (Hyper Text Transfer Protocol) 超文本传输协议
    - http请求过程
      - DNS解析 -> 建立TCP连接 -> 发送请求头和请求行 -> 发送请求体 -> 等待服务器返回首字节(响应头) -> 接收数据
    - HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
    - http报文
      - 请求报文包含三部分：
        - 请求行：包含请求方法、URI、HTTP版本信息
        - 请求头（首部字段、header）
        - 请求体（具体数据）
      - 响应报文包含三部分：
        - 状态行：包含HTTP版本、状态码、状态码的原因短语
        - 响应头（首部字段、header）
        - 响应体

      ![原理图](../../assets/image/http报文.png)

  - TCP三次握手
    - Client端 向 Server端 发送连接请求报文 SYN
    - Server端 向 Client端 发送连接请求确认报文 ACK + SYN
    - Client端 想 Server端 发送连接确认报文 ACK

  - TCP四次挥手

  - https
    - https 是以安全为目的的http通道，即http安全版，基于SSL加密和CA身份认证，SSL使用非对称加密进行握手（通信过程中告知后续使用的对称加密密钥），使用对称加密进行后续通信
      - 加密算法
        - 非对称加密（RSA加密）运用于握手阶段
          > - 即使用公钥加密，使用对应的私钥解密
          > - 算法强度复杂、安全性依赖于算法，两种密钥，其中一个是公开的，一种是私有的，安全性高
          > - 缺点：由于其算法复杂，加密解密速度效率低

        - 对称加密 运用于会话阶段
          > - 即使用主密钥加密，使用主密钥解密
          > - 优点：算法公开、计算量小、加密速度快、加密效率高、可逆
          > - 缺点：双方使用相同钥匙，安全性得不到保证

      - SSL加密原理[参考](https://blog.csdn.net/chenxu6/article/details/53290858)
        - 客户端 发起请求，将版本信息、加密套件可选列表，压缩算法可选列表、随机数(random_C)、扩展字段等信息发送给服务端

        - 服务端 接收到数据后返回协商的信息结果（包含：使用协议的版本号、选择的加密套件、选择的压缩算法、随机数(random_S)、server_certificates服务端CA证书）

        - 客户端 接收到数据后，开始验证CA证书的合法性，验证通过才会进行后续通信，否则断开连接，返回错误信息
          > - 证书链的可信性 trusted certificate path
          > - 证书是否吊销 revocation，有两类方式离线 CRL 与在线 OCSP
          > - 证书的有效期 expiry date
          > - 核查证书域名（domain）是否与当前的访问域名匹配  

        - 客户端 验证通过后(确认服务端身份)
          > - 计算产生随机数(Pre-master)，再使用随机数（random_C、random_S、Pre-master）生成协商密钥
          > - 并且把经过CA证书公钥加密的随机数（Pre-master）以及使用协商密钥和算法加密通信的信息（所有通信参数的 hash 值与其它相关信息，生成一段数据）发送给服务端  

        - 服务端 接收到客户端发送的加密后的随机数(Pre-master)及加密的通信数据
          > - 使用CA证书携带的私钥，解密随机数，同样使用随机数（random_C、random_S、Pre-master）生成协商密钥
          > - 计算之前所有接收信息的 hash 值，使用协商密钥解密客户端发送的加密通信数据，拿到通信的hash值与自己产生的hash值比对，验证密钥和数据的正确性
          > - 服务端告知客户端后续的通信方式都采取协商密钥和加密算法通信，并把将所有至当前的通信的hash值使用协商密钥和加密算法加密发送给客户端

        - 客户端 接收到服务端此时发送的数据
          > - 计算所有接收信息的 hash 值
          > - 并使协商密钥和加密算法解密服务端发送的数据，拿到通信记录的hash值与自己产生的hash值比对，验证密钥和数据的准确性
          > - 验证通过完成握手，否则断开连接

  - http1.1
    - TCP持久连接（HTTP Persistent Connections）
      > 任意一端没有明确提出断开连接，则保持TCP连接状态  
      > Connections: keep-alive

    - 管线化(也叫流水线)（pipelining)
      > 不用等待响应亦可直接发送下一个请求。http1.0发送请求后需要等待并且收到响应后才能发送下一个请求

    - 分块传输编码（Chunked TransferCoding）
      > 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度(16进制)，最后用一个零长度（0（CR+LF））的块作为消息结束的标志。

  - http2.0
    - 多路复用（一条TCP连接并发处理多个请求）
    - 数据压缩（使用HPACK算法对header的数据进行压缩）
    - 服务器推送


### http常用状态码

    100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息

    200  OK         正常返回信息
    201  Created    请求成功并且服务器创建了新的资源
    202  Accepted   服务器已接受请求，但尚未处理
    206  Partial Content 成功执行了一个部分或Range(范围)请求。206响应中必须包含Content-Range、Date以及ETag或Content-Location首部。

    (重定向)
    301  Moved Permanently  请求的网页已永久移动到新位置。
    302  Found        临时性重定向。
    303  See Other    临时性重定向，且总是使用 GET 请求新的 URI。
    304  Not Modified 自从上次请求后，请求的网页未修改过。

    (客户端错误)
    400  Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
    401  Unauthorized 请求未授权。
    403  Forbidden    禁止访问。
    404  Not Found    找不到如何与 URI 相匹配的资源。

    (服务端错误)
    500  Internal Server Error  最常见的服务器端错误。
    503  Service Unavailable    服务器端暂时无法处理请求（可能是过载或维护）。

### 浏览器攻击（XSS、CSRF）[来源](https://mp.weixin.qq.com/s/sjy-Kul5y0Wj-HJwQn7gBA)
    - XSS 跨站脚本注入攻击
      - 原理：服务端过于信任客户端提交的数据，没有对提交的信息进行过滤
      - 解决：
        1. 输入输出内容检查并过滤
        2. Cookie中设置HttpOnly (设置HttpOnly的Cookie通过js脚本将无法读取到)

    - CSRF 跨站请求伪造(挟持)
      - 要求：
        1. 登录受信任网站A，并在本地生成Cookie。
        2. 在不登出A的情况下，访问危险网站B。B网站拿到A网站的cookie，并发送请求。
      - 解决：
        1. 验证码
        2. 请求验证Referer来源
        3. token验证（jwt）

### TCP和UDP的区别
  - TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。
  - TCP提供可靠的服务  
    > 即通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。

  - UDP尽最大努力交付，即不保证可靠交付，数据传输后需无应答。
  - TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。
  - TCP只能是1对1的，UDP支持1对1，1对多。
  - TCP的首部较大为20字节，而UDP只有8字节。


### POST 与 GET 区别

##### 表层上的区别：  
> 1、GET在浏览器回退时是无害的，而POST会再次提交请求。  
  2、GET产生的URL地址可以被Bookmark，而POST不可以。  
  3、GET请求会被浏览器主动cache，而POST不会，除非手动设置。  
  4、GET请求只能进行url编码，而POST支持多种编码方式。  
  5、GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。  
  6、GET请求在URL中传送的参数是有长度限制的，而POST么有。  
  7、对参数的数据类型，GET只接受ASCII字符，而POST没有限制。  
  8、GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。  
  9、GET参数通过URL传递，POST放在Request body中。  
  （本标准答案参考自w3schools）

##### HTTP协议：
> HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。

> GET和POST的底层也是TCP/IP.即GET和POST在本质上是一致的，都是TCP/IP协议。

##### 业内规定：
> 1、（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。  
  2、

###### GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同

#### 本质区别
GET产生一个TCP数据包；POST产生两个TCP数据包。
> GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）  
而POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

#### 总结
> 1、因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。  
 2、 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
 3、 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。
